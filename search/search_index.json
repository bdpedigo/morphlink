{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"examples/microns_example/","title":"Microns example","text":"<p>Note: while these packages are not required for the use of MorphLink, they are used here to demonstrate the functionality of the package with real data and integration with multiple other packages. This tutorial requires:</p> <ul> <li><code>CAVEclient</code>,</li> <li><code>skeletor</code>,</li> <li><code>pcg_skel</code>,</li> <li><code>pyvista</code>,</li> </ul> <p>all of which are available on PyPI.</p> <pre><code>from caveclient import CAVEclient\n\nclient = CAVEclient(\"minnie65_public\")\n</code></pre> <p>Create a <code>MorphLink</code> instance. This is the object we'll use for keeping track of different features and representations of morphology.</p> <pre><code>from morphlink import MorphLink\n\nmorphology = MorphLink()\n</code></pre> <p>We'll start by getting the morphology of a single neuron as a mesh.</p> <pre><code>root_id = 864691135361314119\n\ncv = client.info.segmentation_cloudvolume()\nmesh = cv.mesh.get(root_id)[root_id]\n</code></pre> <pre>\n<code>Downloading Meshes: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:23&lt;00:00, 23.81s/it]</code>\n</pre> <pre>\n<code>Warning: deduplication not currently supported for this layer's variable layered draco meshes\n</code>\n</pre> <pre>\n<code>\n</code>\n</pre> <p>We can add this to our morphology representation using the <code>add_mesh</code> method.</p> <pre><code>morphology.add_mesh(mesh, \"mesh\")\nmorphology.layers\n</code></pre> layer layer_type name mesh Mesh(vertices=(2652062, 3), faces=(5293626, 3)) Mesh <p>Next, we can add the nucleus location for this neuron. This is a new type of layer, in this case just a single point.</p> <pre><code>nuc_info = client.materialize.query_table(\n    \"nucleus_detection_v0\",\n    filter_equal_dict={\"pt_root_id\": root_id},\n    split_positions=True,\n    desired_resolution=[1, 1, 1],\n)\nnuc_loc = nuc_info[[\"pt_position_x\", \"pt_position_y\", \"pt_position_z\"]].values.squeeze()\nnuc_loc\n</code></pre> <pre>\n<code>array([725760., 491456., 853080.])</code>\n</pre> <pre><code>morphology.add_points(nuc_loc, \"nucleus\")\n</code></pre> <pre><code>morphology.layers\n</code></pre> layer layer_type name mesh Mesh(vertices=(2652062, 3), faces=(5293626, 3)) Mesh nucleus Points(points=(1, 3)) Points <pre><code>polydatas = morphology.to_pyvista()\n\nimport pyvista as pv\n\nWINDOW_SIZE = [2400, 1500]\npv.set_jupyter_backend(\"static\")\nplotter = pv.Plotter(window_size=WINDOW_SIZE)\nplotter.add_mesh(polydatas[\"mesh\"], color=\"lightgrey\", opacity=0.5)\nplotter.add_points(\n    polydatas[\"nucleus\"], color=\"red\", point_size=60, render_points_as_spheres=True\n)\nplotter.camera.focal_point = nuc_loc\nplotter.camera.zoom(5)\nplotter.show()\n</code></pre> <p>Similarly, we can add another layer that consists of many points - in this case, synapses onto this neuron.</p> <pre><code>post_synapses = client.materialize.query_table(\n    \"synapses_pni_2\",\n    filter_equal_dict={\"post_pt_root_id\": root_id},\n    split_positions=True,\n    desired_resolution=[1, 1, 1],\n)\npost_synapses.set_index(\"id\", inplace=True)\n</code></pre> <p>By setting the <code>spatial_columns</code> argument, we can specify which columns in the DataFrame correspond to spatial coordinates. This allows future methods to do space-aware operations on this layer. In the example above for the nucleus, the spatial columns were inferred since we passed in a 3-dimensional array.</p> <pre><code>morphology.add_points(\n    post_synapses,\n    \"post_synapses\",\n    spatial_columns=[\"ctr_pt_position_x\", \"ctr_pt_position_y\", \"ctr_pt_position_z\"],\n)\n</code></pre> <p>Now, let's link some of these objects together. The simplest mapping is to annotate the nucleus location on the mesh. Under the hood, the <code>add_link</code> method will find the closest point on the mesh and save that mapping.</p> <pre><code>morphology.add_link(\"nucleus\", \"mesh\")\n\nmorphology.links\n</code></pre> link source target nucleus mesh nucleus     mesh 0        0  1220064 <pre><code>plotter = pv.Plotter(window_size=WINDOW_SIZE)\nplotter.add_mesh(polydatas[\"mesh\"], color=\"lightgrey\")\nplotter.add_points(\n    morphology.post_synapses.to_pyvista(),\n    color=\"blue\",\n    point_size=10,\n    render_points_as_spheres=True,\n)\nplotter.camera.focal_point = nuc_loc\nplotter.camera.zoom(5)\nplotter.show()\n</code></pre> <p>Again, we can do this for synapses as well, here again finding the closest point on the mesh for each synapse.</p> <pre><code>morphology.add_link(\"post_synapses\", \"mesh\")\n\nmorphology.links\n</code></pre> link source target nucleus mesh nucleus     mesh 0        0  1220064 post_synapses mesh post_synapses     mesh 0         1873158... <p>We can retreive the mapping between the nucleus and the mesh using the <code>get_link</code> method. This returns a DataFrame with the mapping as its two columns.</p> <pre><code>morphology.get_link(\"nucleus\", \"mesh\")\n</code></pre> nucleus mesh 0 0 1220064 <p>We can also ask for the specific mapping for a point in our nucleus layer. Since we only have one point in this layer, we just get one item back from the mapping, denoting the closest point on the mesh.</p> <pre><code>mesh_nuc_index = morphology.get_mapping(\"nucleus\", \"mesh\")\n\nmesh_nuc_index\n</code></pre> <pre>\n<code>Index([1220064], dtype='int64', name='mesh')</code>\n</pre> <p>Now, we can do something a bit more interesting. Let's skeletonize the mesh, using the nucleus as the source points for the skeletonization.</p> <p>Note: requires <code>skeletor</code> package to be installed.</p> <pre><code>import time\n\nfrom skeletor.skeletonize import by_wavefront\n\ncurrtime = time.time()\n\nout = by_wavefront(mesh, origins=mesh_nuc_index.to_list(), progress=True)\nprint(f\"{time.time() - currtime:.3f} seconds elapsed.\")\n</code></pre> <pre>\n<code>Skeletonizing:   0%|          | 0/2652062 [00:00&lt;?, ?it/s]</code>\n</pre> <pre>\n<code>26.028 seconds elapsed.\n</code>\n</pre> <p>This skeletonization process stores the mapping between mesh vertices and the new, collapsed vertices from the skeletonization. First, let's add the skeleton to our morphology representations.</p> <pre><code>morphology.add_graph(out, \"skeleton\")\n</code></pre> <pre><code>plotter = pv.Plotter(window_size=WINDOW_SIZE)\nplotter.add_mesh(morphology.mesh.to_pyvista(), color=\"lightgrey\", opacity=0.3)\nplotter.add_mesh(\n    morphology.post_synapses.to_pyvista(),\n    color=\"blue\",\n    point_size=10,\n    render_points_as_spheres=True,\n)\nplotter.add_mesh(morphology.skeleton.to_pyvista(), color=\"red\", line_width=2)\nplotter.camera.focal_point = nuc_loc\nplotter.camera.zoom(10)\nplotter.show()\n</code></pre> <p>Then, we can add the mapping between the mesh and the skeleton. This mapping is stored in the <code>mesh_map</code> attribute of the skeletonization output.</p> <pre><code>morphology.add_link(\"mesh\", \"skeleton\", mapping=out.mesh_map)\n</code></pre> <pre><code>morphology.links\n</code></pre> link source target nucleus mesh nucleus     mesh 0        0  1220064 post_synapses mesh post_synapses     mesh 0         1873158... mesh skeleton mesh  skeleton 0              0   ... <p>Now, we might also be interested in where synapses are located along the skeleton. Even though the skeletonization map doesn't have a direct mapping between the mesh and the synapses, we can first map synapses to their points on the mesh, and then map those mesh points to their points on the skeleton.</p> <p>Fortunately, this kind of transitive mapping is handled automatically by MorphLink under the hood. Internally, there is a graph that denotes relationships between different layers, and the <code>link_path</code> method can be used to find the path from a source layer to a target layer (if one exists).</p> <p>Many times, this will just be a direct link.</p> <pre><code>morphology.get_link_path(\"post_synapses\", \"mesh\")\n</code></pre> <pre>\n<code>['post_synapses', 'mesh']</code>\n</pre> <p>But as in the case of the synapses and the skeleton, it will find the path that involves mapping synapses to the mesh, and then the mesh to the skeleton.</p> <pre><code>morphology.get_link_path(\"post_synapses\", \"skeleton\")\n</code></pre> <pre>\n<code>['post_synapses', 'mesh', 'skeleton']</code>\n</pre> <pre><code>synapse_skeleton_ids = morphology.get_mapping(\"post_synapses\", \"skeleton\")\nsynapse_skeleton_ids\n</code></pre> <pre>\n<code>Index([124839,  64175, 121215, 115029,  54276,  10115,  46720, 114390, 103022,\n        53731,\n       ...\n        48629, 123062,  46546, 133495, 116864,  27888,  71817,  67137, 116485,\n       116624],\n      dtype='int64', name='skeleton', length=3216)</code>\n</pre> <pre><code>skeleton_synapse_points = morphology.skeleton.nodes.iloc[synapse_skeleton_ids]\n\nplotter = pv.Plotter(window_size=WINDOW_SIZE)\nplotter.add_mesh(morphology.skeleton.to_pyvista(), color=\"red\", line_width=1)\nplotter.add_points(\n    skeleton_synapse_points.values,\n    color=\"blue\",\n    point_size=5,\n    render_points_as_spheres=True,\n)\nplotter.camera.focal_point = nuc_loc\nplotter.camera.zoom(5)\nplotter.show()\n</code></pre>"},{"location":"examples/microns_example/#initialization","title":"Initialization","text":"<p>Start a CAVEclient</p>"},{"location":"examples/microns_example/#adding-a-mesh","title":"Adding a mesh","text":""},{"location":"examples/microns_example/#adding-point-annotations","title":"Adding point annotations","text":""},{"location":"examples/microns_example/#adding-a-skeleton","title":"Adding a skeleton","text":""},{"location":"examples/microns_example/#more-complex-mappings","title":"More complex mappings","text":""}]}